# RFM Customer Segmentation (E-commerce Retail)

## 1) Project Overview
### Objective

#### **üìñ What is this project about?**

Build a customer segmentation workflow using the RFM (Recency‚ÄìFrequency‚ÄìMonetary) framework to classify SuperStore customers into meaningful groups (e.g., Champions, Loyal, At Risk‚Ä¶) and support targeted marketing campaigns for the Christmas & New Year season.

#### **üôãüèª‚Äç‚ôÇÔ∏è Who is this project for?**

- **Marketing team:** design different campaign offers for each customer segment (loyalty, win-back, upsell).
- **Business stakeholders (Marketing Director):** prioritize budget and identify high-value customers.
- **Data/Analytics team:** provide a scalable segmentation pipeline (Python) instead of manual Excel classification.


#### **Business Context**

SuperStore is a global retail company with a large and growing customer base. During the holiday season, Marketing wants to:
- **Reward customers** who have supported the company,
- **Activate/push potential customers** to become loyal customers.

‚ùóÔ∏è In previous years, segmentation could be done manually in Excel, but the dataset has grown too large. Therefore, the Analytics team is asked to implement an automated approach using python

#### **‚ùìBusiness Questions**

- How can we segment customers based on purchasing behavior this year?
- Which segments should be prioritized for holiday campaigns (retention vs reactivation vs growth)?
- What actions/offer strategy shoukd Marketing apply for each segment?

---

### RFM Analysis Overview 

#### **Why use RFM?**

RFM is a practical and business-friendly model because it converts transaction history into three easy-to-explain signals:

- Recency (R): How recently a customer purchased
  - ‚û°Ô∏è identifies active vs inactive customers
  
- Frequency (F): How often a customer purchases
  - ‚û°Ô∏è identifies loyal / repeat buyers
  
- Monetary (M): How much a customer spends
  - ‚û°Ô∏è identifies high-value customers
 

## 2) Dataset Description & Data structure

### Data Source
- **Source:** Provided dataset for E-commerce retail analysis  
- **Format:** `.xlsx` (Excel workbook with **2 sheets**)  
- **Size:** **541,910 rows √ó 8 columns** (Sheet 1: *E-commerce Retail*).  
  Sheet 2 includes customer-level segmentation outputs (RFM scores & segment labels).

---
### Data Structure & Relationships

#### 1Ô∏è‚É£ Sheets Used (Tables)
This workbook contains two tables (sheets):

- **Sheet 1 ‚Äî E-commerce Retail (Transaction-level):**  
  Contains transaction-level data, including order details, customer IDs, and purchase information..

- **Sheet 2 ‚Äî Segmentation (Customer-level):**  
  Customer segmentation results with **RFM scores** and **segment labels**.

#### 2Ô∏è‚É£ Schema & Data Snapshot

üìå **Sheet 1: E-commerce Retail**  
- **Grain:** 1 row = 1 line item in an invoice (**InvoiceNo √ó StockCode**).
- **Table Schema:** *E-commerce Retail*  
<details>
  <summary>üìÇ <b>Dataset Schema</b> (Click to expand)</summary>
  <br>

| Column Name | Data Type | Description |
|---|---|---|
| InvoiceNo | object | Unique invoice number (6-digit). If starts with 'C', it indicates a cancellation. |
| StockCode | object | Unique product (item) code. |
| Description | object | Product (item) name. |
| Quantity | int64 | Number of units purchased per transaction line. |
| InvoiceDate | datetime64[ns] | Date & time when the transaction occurred. |
| UnitPrice | float64 | Price per unit (GBP). |
| CustomerID | float64 | Unique customer identifier. |
| Country | object | Customer's country. |

</details>


üìå **Sheet 2: Segmentation**  
- **Grain:** 1 row = 1 customer  (**CustomerID**)
- **Purpose:** Stores RFM scores and segment labels for each customer.
  
<details>
  <summary>üìÇ <b>Segmentation Schema</b> (Click to expand)</summary>
  <br>

| Column Name | Data Type | Description |
|---|---|---|
| CustomerID | float64 / int | Unique customer identifier (key to join with Sheet 1). |
| Recency | int | Days since the customer‚Äôs most recent purchase (lower = more recent). |
| Frequency | int | Number of unique invoices/orders made by the customer. |
| Monetary | float | Total revenue generated by the customer (Quantity √ó UnitPrice). |
| R_Score | int | Recency score (typically 1‚Äì5). |
| F_Score | int | Frequency score (typically 1‚Äì5). |
| M_Score | int | Monetary score (typically 1‚Äì5). |
| RFM_Score | string/int | Combined score (e.g., 555). Used for mapping to a segment. |
| Segment | object/string | Segment label (e.g., Champions, Loyal, At Risk). |

</details>

---



## 3) Exploratory Data Analysis (EDA)

**Code cell [1Ô∏è‚É£]**
- Load dataset from Excel and preview the first few rows
```python
df = pd.read_excel("/content/ecommerce retail.xlsx")

df.head()
```
**Output**
<img width="975" height="173" alt="AÃânh maÃÄn hiÃÄnh 2026-02-28 luÃÅc 11 57 57" src="https://github.com/user-attachments/assets/656aa782-e566-48f5-8fee-4c47b5e0d7d9" />


**Code cell [2Ô∏è‚É£]**
- Dataset overview: columns names and dimemsions (row, columns)
```python
display(df.columns)
display(df.shape)
```

**Output**

<img width="632" height="90" alt="AÃânh maÃÄn hiÃÄnh 2026-02-28 luÃÅc 14 57 20" src="https://github.com/user-attachments/assets/e4c9d882-421c-4e68-bd12-df3eeb0239ee" />



**Code cell [3Ô∏è‚É£]**
- Reviewed data types and missing values (`df.info()`).
- Counted total rows, unique invoices, and unique customers (including vs excluding null `CustomerID`).
- Confirmed the transaction period by checking `InvoiceDate` min/max.

```python
df.info()

n_rows = len(df)
n_invoices = df['InvoiceNo'].nunique()
n_customers_all = df["CustomerID"].nunique(dropna =False)
n_customers_notnull = df["CustomerID"].nunique(dropna=True)

print(f"Number of rows: {n_rows}")
print(f"Number of invoices: {n_invoices}")
print(f"Number of customers (all): {n_customers_all}")
print(f"Number of customers (not null): {n_customers_notnull}")
print ("date min:", df["InvoiceDate"].min())
print ("date max:", df["InvoiceDate"].max())
```

**Output**

<img width="792" height="358" alt="AÃânh maÃÄn hiÃÄnh 2026-02-28 luÃÅc 15 15 26" src="https://github.com/user-attachments/assets/cc9f1db4-ca9d-44f4-a915-e9f40621fa4a" />



**Code cell [4Ô∏è‚É£]**
```python
df.describe()
```

**Output**

<img width="793" height="261" alt="AÃânh maÃÄn hiÃÄnh 2026-02-28 luÃÅc 18 47 11" src="https://github.com/user-attachments/assets/4d83e192-c3fc-4dca-8518-6b45ca58057c" />


### Summary
- The dataset contains 541,909 transaction line items, spanning 25,900 unique invoices and 8 columns (`InvoiceNo`, `StockCode`, `Description`, `Quantity`, `InvoiceDate`, `UnitPrice`, `CustomerID`, `Country`).
- Transactions cover the period `2010-12-01 to 2011-12-09`.
- Missing values are present, especially CustomerID (406,829 non-null out of 541,909), which impacts customer-level analyses.
- `describe()` indicates negative values in Quantity and UnitPrice, suggesting cancellations/returns or invalid transactions that must be handled before analysis.
- Based on dataset validation, invoices with `InvoiceNo` starting with ‚ÄúC‚Äù are treated as cancellation (credit) transactions.



### üí°Conclusion
- This dataset is at the invoice-line grain (multiple items per invoice), suitable for product, invoice, and customer analyses after cleaning.
- For data integrity:
  - Remove cancellation transactions where InvoiceNo starts with ‚ÄúC‚Äù (credit notes) to avoid negative revenue distortion.
  - Investigate and handle negative Quantity/UnitPrice records that are not cancellations (potential data errors or special adjustments).
  - Decide how to treat rows with missing CustomerID depending on analysis goals.


## 4) Data Cleaning & Preprocessing

RFM segmentation must reflect real purchase behavior. Missing CustomerID, cancellations, and non-positive Quantity/UnitPrice can distort Monetary and Frequency, leading to wrong customer segments and misleading marketing decisions.

**Cleaning rules applied:**

- Remove row with missing CustomerID (cannot assign purchases to a customer).
- Exclude cancelled invoices (InvoiceNo starts with"C")
- keep only valid sales transactions where Quanity > 0 and UnitPrice > 0.
- Create Sales = Quantity * UnitPrice to represent trasaction value (Monetary)

**Code cell5Ô∏è‚É£**
```python
df2= df.copy()
df2["InvoiceDate"] = pd.to_datetime(df2["InvoiceDate"])


# drop CustomerID null
# remove cancelled invoices (InvoiceNO start with"C")
# keep Quanity > 0, UnitPrice > 0
#remove __isNull (Use ~ to reverse the condition.)


df2 = df2 [
    (~df2["CustomerID"].isnull()) & #  ~ to reverse the condition.
    (~df2["InvoiceNo"].astype(str).str.startswith("C", na=False)) &
    (df2["Quantity"]>0) &
    (df2["UnitPrice"]>0)
]
df2["Sales"] = df2["Quantity"]*df2["UnitPrice"]
print(f"Data before cleaning: {df.shape}")
print(f"Data after cleaning: {df2.shape}")
print(f"Number of rows dropped: {len(df)-len(df2)}")

#sanity check
assert df2["CustomerID"].notna().all()
assert (~df2["InvoiceNo"].astype(str).str.startswith("C", na=False).all())
assert (df2["Quantity"]>0).all()
assert (df2["UnitPrice"]>0).all()
```

**Output**

<img width="327" height="61" alt="AÃânh maÃÄn hiÃÄnh 2026-02-28 luÃÅc 19 48 37" src="https://github.com/user-attachments/assets/e763cb31-2929-4602-adc6-465c4dbd703a" />




## 5) Apply RFM Model

## 6) Visualization & Analysis

## 7) Insight & Recommendation
