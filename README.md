# RFM Customer Segmentation (E-commerce Retail)

## 1) Project Overview
### Objective

#### **üìñ What is this project about?**

Build a customer segmentation workflow using the RFM (Recency‚ÄìFrequency‚ÄìMonetary) framework to classify SuperStore customers into meaningful groups (e.g., Champions, Loyal, At Risk‚Ä¶) and support targeted marketing campaigns for the Christmas & New Year season.

#### **üôãüèª‚Äç‚ôÇÔ∏è Who is this project for?**

- **Marketing team:** design different campaign offers for each customer segment (loyalty, win-back, upsell).
- **Business stakeholders (Marketing Director):** prioritize budget and identify high-value customers.
- **Data/Analytics team:** provide a scalable segmentation pipeline (Python) instead of manual Excel classification.


#### **Business Context**

SuperStore is a global retail company with a large and growing customer base. During the holiday season, Marketing wants to:
- **Reward customers** who have supported the company,
- **Activate/push potential customers** to become loyal customers.

‚ùóÔ∏è In previous years, segmentation could be done manually in Excel, but the dataset has grown too large. Therefore, the Analytics team is asked to implement an automated approach using python

#### **‚ùìBusiness Questions**

- How can we segment customers based on purchasing behavior this year?
- Which segments should be prioritized for holiday campaigns (retention vs reactivation vs growth)?
- What actions/offer strategy shoukd Marketing apply for each segment?

---

### RFM Analysis Overview 

#### **Why use RFM?**

RFM is a practical and business-friendly model because it converts transaction history into three easy-to-explain signals:

- Recency (R): How recently a customer purchased
  - ‚û°Ô∏è identifies active vs inactive customers
  
- Frequency (F): How often a customer purchases
  - ‚û°Ô∏è identifies loyal / repeat buyers
  
- Monetary (M): How much a customer spends
  - ‚û°Ô∏è identifies high-value customers
 

## 2) Dataset Description & Data structure

### Data Source
- **Source:** Provided dataset for E-commerce retail analysis  
- **Format:** `.xlsx` (Excel workbook with **2 sheets**)  
- **Size:** **541,910 rows √ó 8 columns** (Sheet 1: *E-commerce Retail*).  
  Sheet 2 includes customer-level segmentation outputs (RFM scores & segment labels).

---
### Data Structure & Relationships

#### 1Ô∏è‚É£ Sheets Used (Tables)
This workbook contains two tables (sheets):

- **Sheet 1 ‚Äî E-commerce Retail (Transaction-level):**  
  Contains transaction-level data, including order details, customer IDs, and purchase information..

- **Sheet 2 ‚Äî Segmentation (Customer-level):**  
  Customer segmentation results with **RFM scores** and **segment labels**.

#### 2Ô∏è‚É£ Schema & Data Snapshot

üìå **Sheet 1: E-commerce Retail**  
- **Grain:** 1 row = 1 line item in an invoice (**InvoiceNo √ó StockCode**).
- **Table Schema:** *E-commerce Retail*  
<details>
  <summary>üìÇ <b>Dataset Schema</b> (Click to expand)</summary>
  <br>

| Column Name | Data Type | Description |
|---|---|---|
| InvoiceNo | object | Unique invoice number (6-digit). If starts with 'C', it indicates a cancellation. |
| StockCode | object | Unique product (item) code. |
| Description | object | Product (item) name. |
| Quantity | int64 | Number of units purchased per transaction line. |
| InvoiceDate | datetime64[ns] | Date & time when the transaction occurred. |
| UnitPrice | float64 | Price per unit (GBP). |
| CustomerID | float64 | Unique customer identifier. |
| Country | object | Customer's country. |

</details>


üìå **Sheet 2: Segmentation**  
- **Grain:** 1 row = 1 customer  (**CustomerID**)
- **Purpose:** Stores RFM scores and segment labels for each customer.
  
<details>
  <summary>üìÇ <b>Segmentation Schema</b> (Click to expand)</summary>
  <br>

| Column Name | Data Type | Description |
|---|---|---|
| CustomerID | float64 / int | Unique customer identifier (key to join with Sheet 1). |
| Recency | int | Days since the customer‚Äôs most recent purchase (lower = more recent). |
| Frequency | int | Number of unique invoices/orders made by the customer. |
| Monetary | float | Total revenue generated by the customer (Quantity √ó UnitPrice). |
| R_Score | int | Recency score (typically 1‚Äì5). |
| F_Score | int | Frequency score (typically 1‚Äì5). |
| M_Score | int | Monetary score (typically 1‚Äì5). |
| RFM_Score | string/int | Combined score (e.g., 555). Used for mapping to a segment. |
| Segment | object/string | Segment label (e.g., Champions, Loyal, At Risk). |

</details>

---



## 3) Exploratory Data Analysis (EDA)

**Code cell [1Ô∏è‚É£]**
- Load dataset from Excel and preview the first few rows
```python
df = pd.read_excel("/content/ecommerce retail.xlsx")

df.head()
```
**Output**
<img width="975" height="173" alt="AÃânh maÃÄn hiÃÄnh 2026-02-28 luÃÅc 11 57 57" src="https://github.com/user-attachments/assets/656aa782-e566-48f5-8fee-4c47b5e0d7d9" />


**Code cell [2Ô∏è‚É£]**
- Dataset overview: columns names and dimemsions (row, columns)
```python
display(df.columns)
display(df.shape)
```

**Output**

<img width="632" height="90" alt="AÃânh maÃÄn hiÃÄnh 2026-02-28 luÃÅc 14 57 20" src="https://github.com/user-attachments/assets/e4c9d882-421c-4e68-bd12-df3eeb0239ee" />



**Code cell [3Ô∏è‚É£]**
- Reviewed data types and missing values (`df.info()`).
- Counted total rows, unique invoices, and unique customers (including vs excluding null `CustomerID`).
- Confirmed the transaction period by checking `InvoiceDate` min/max.

```python
df.info()

n_rows = len(df)
n_invoices = df['InvoiceNo'].nunique()
n_customers_all = df["CustomerID"].nunique(dropna =False)
n_customers_notnull = df["CustomerID"].nunique(dropna=True)

print(f"Number of rows: {n_rows}")
print(f"Number of invoices: {n_invoices}")
print(f"Number of customers (all): {n_customers_all}")
print(f"Number of customers (not null): {n_customers_notnull}")
print ("date min:", df["InvoiceDate"].min())
print ("date max:", df["InvoiceDate"].max())
```

**Output**

<img width="792" height="358" alt="AÃânh maÃÄn hiÃÄnh 2026-02-28 luÃÅc 15 15 26" src="https://github.com/user-attachments/assets/cc9f1db4-ca9d-44f4-a915-e9f40621fa4a" />



**Code cell [4Ô∏è‚É£]**
```python
df.describe()
```

**Output**

<img width="793" height="261" alt="AÃânh maÃÄn hiÃÄnh 2026-02-28 luÃÅc 18 47 11" src="https://github.com/user-attachments/assets/4d83e192-c3fc-4dca-8518-6b45ca58057c" />


### Summary
- The dataset contains 541,909 transaction line items, spanning 25,900 unique invoices and 8 columns (`InvoiceNo`, `StockCode`, `Description`, `Quantity`, `InvoiceDate`, `UnitPrice`, `CustomerID`, `Country`).
- Transactions cover the period `2010-12-01 to 2011-12-09`.
- Missing values are present, especially CustomerID (406,829 non-null out of 541,909), which impacts customer-level analyses.
- `describe()` indicates negative values in Quantity and UnitPrice, suggesting cancellations/returns or invalid transactions that must be handled before analysis.
- Based on dataset validation, invoices with `InvoiceNo` starting with ‚ÄúC‚Äù are treated as cancellation (credit) transactions.



### üí°Conclusion
- This dataset is at the invoice-line grain (multiple items per invoice), suitable for product, invoice, and customer analyses after cleaning.
- For data integrity:
  - Remove cancellation transactions where InvoiceNo starts with ‚ÄúC‚Äù (credit notes) to avoid negative revenue distortion.
  - Investigate and handle negative Quantity/UnitPrice records that are not cancellations (potential data errors or special adjustments).
  - Decide how to treat rows with missing CustomerID depending on analysis goals.


## 4) Data Cleaning & Preprocessing

RFM segmentation must reflect real purchase behavior. Missing CustomerID, cancellations, and non-positive Quantity/UnitPrice can distort Monetary and Frequency, leading to wrong customer segments and misleading marketing decisions.

**Cleaning rules applied:**

- Remove row with missing CustomerID (cannot assign purchases to a customer).
- Exclude cancelled invoices (InvoiceNo starts with"C")
- keep only valid sales transactions where Quanity > 0 and UnitPrice > 0.
- Create Sales = Quantity * UnitPrice to represent trasaction value (Monetary)

**Code cell5Ô∏è‚É£**
```python
df2= df.copy()
df2["InvoiceDate"] = pd.to_datetime(df2["InvoiceDate"])


# drop CustomerID null
# remove cancelled invoices (InvoiceNO start with"C")
# keep Quanity > 0, UnitPrice > 0
#remove __isNull (Use ~ to reverse the condition.)


df2 = df2 [
    (~df2["CustomerID"].isnull()) & #  ~ to reverse the condition.
    (~df2["InvoiceNo"].astype(str).str.startswith("C", na=False)) &
    (df2["Quantity"]>0) &
    (df2["UnitPrice"]>0)
]
df2["Sales"] = df2["Quantity"]*df2["UnitPrice"]
print(f"Data before cleaning: {df.shape}")
print(f"Data after cleaning: {df2.shape}")
print(f"Number of rows dropped: {len(df)-len(df2)}")

#sanity check
assert df2["CustomerID"].notna().all()
assert (~df2["InvoiceNo"].astype(str).str.startswith("C", na=False).all())
assert (df2["Quantity"]>0).all()
assert (df2["UnitPrice"]>0).all()
```

**Output**

<img width="327" height="61" alt="AÃânh maÃÄn hiÃÄnh 2026-02-28 luÃÅc 19 48 37" src="https://github.com/user-attachments/assets/e763cb31-2929-4602-adc6-465c4dbd703a" />




## 5) RFM Scoring & Customer Segments

### Build RFM metric

- **Purpose:** aggregate transaction-level data to customer-level RFM metrics.
- **Output:** a table with Recency/Frequency/Monetary per customer.

**Code cell6Ô∏è‚É£**
```
snapshot = pd.Timestamp("2011-12-31")

rfm = (
    df2.groupby("CustomerID")
    .agg(
        Recency = ("InvoiceDate", lambda x: (snapshot - x.max()).days),
        Frequency = ("InvoiceNo", "nunique"),
        Monetary = ("Sales", "sum")
    )
)
rfm.head()
```

**Output**

<img width="805" height="206" alt="AÃânh maÃÄn hiÃÄnh 2026-03-01 luÃÅc 07 19 47" src="https://github.com/user-attachments/assets/4a6c790f-fa6c-4dff-8824-5cb04cae7ee0" />


### Score customers

- **Purpose:** convert R/F/M into 1‚Äì5 scores and create RFM code.
- **Output:** R_Score, F_Score, M_Score, RFM_Score.

**Code cell7Ô∏è‚É£**
```
rfm = rfm.copy()

rfm['R_Score'] = pd.qcut(rfm['Recency'],5, labels=[5,4,3,2,1]).astype(int)
rfm['F_Score'] = pd.qcut(rfm['Frequency'].rank(method='first'),5, labels=[1,2,3,4,5]).astype(int)
rfm['M_Score'] = pd.qcut(rfm['Monetary'],5, labels=[1,2,3,4,5]).astype(int)

rfm["RFM_Score"] = (
    rfm["R_Score"].astype(str) +
    rfm["F_Score"].astype(str) +
    rfm["M_Score"].astype(str)
)

rfm.head()
```

**Output**

<img width="789" height="214" alt="AÃânh maÃÄn hiÃÄnh 2026-03-01 luÃÅc 07 24 13" src="https://github.com/user-attachments/assets/35a80c1e-fef2-405b-a263-d5d6e916563e" />

### Summary
Apply RFM Model
- Converted transaction-level data into customer-level RFM metrics by aggregating on CustomerID.
- Defined a snapshot date (2011-12-31) to calculate:
  - Recency: days since the customer‚Äôs most recent purchase (lower is better)
  - Frequency: number of unique invoices/purchases (higher is better)
  - Monetary: total spending (Sales sum) (higher is better)
- Scored customers into quintiles (1‚Äì5) using pd.qcut:
  - R_Score: reversed scale (most recent customers get higher scores)
  - F_Score, M_Score: higher values get higher scores


### Segment mapping 
- **Purpose:** map RFM score patterns to business segments
- **Output:** Segment label per customer + summary table

**Code cell8Ô∏è‚É£**
```python
seg = pd.read_excel('/content/ecommerce retail.xlsx', sheet_name='Segmentation')

seg_map ={}
for _, row in seg.iterrows():
  scores =[s.strip() for s in str(row["RFM Score"]).split(",")]
  seg_map[row["Segment"]] = set(scores)

def assign_segment(score: str) -> str:
  for name, sset in seg_map.items():
    if score in sset:
      return name
  return "Others"

rfm["Segment"] = rfm["RFM_Score"].apply(assign_segment)
rfm
     
```

**Output**
<img width="973" height="385" alt="AÃânh maÃÄn hiÃÄnh 2026-03-01 luÃÅc 07 47 42" src="https://github.com/user-attachments/assets/d09808be-ef05-461a-83a8-9bca9a85114d" />


**Code cell 9Ô∏è‚É£**
```python
# 3 metrics summary table
segment_metrics = (
    rfm.groupby("Segment")
               .agg(
                   customers=("CustomerID", "nunique"),
                   revenue=("Monetary", "sum"),
                   median_recency=("Recency", "median")
               )
               .sort_values("revenue", ascending=False)
)

segment_metrics["customer_pct"] = segment_metrics["customers"] / segment_metrics["customers"].sum()
segment_metrics["revenue_pct"] = segment_metrics["revenue"] / segment_metrics["revenue"].sum()

segment_metrics
```
**Output**
<img width="998" height="374" alt="AÃânh maÃÄn hiÃÄnh 2026-03-01 luÃÅc 07 51 24" src="https://github.com/user-attachments/assets/ce055d7f-3748-4820-81c6-f755e3004b11" />




## 6) Visualization & Analysis
**Create Color map**

**Cell code**
```python
segments = segment_metrics.index.tolist()
cmap = plt.cm.get_cmap("tab20", len(segments))
SEGMENT_COLORS = {seg: cmap(i) for i, seg in enumerate(segments)}
```

**Customer by segment**

**Code cell**
```
s = segment_metrics["customers"].sort_values()
colors = [SEGMENT_COLORS[seg] for seg in s.index]

plt.figure(figsize=(10, 6))
ax = s.plot(kind="barh", color=colors)
ax.grid(axis="x", linestyle="--", alpha=0.3)
ax.spines["top"].set_visible(False)
ax.spines["right"].set_visible(False)
plt.title("Customers by Segment")
plt.xlabel("Customers")
plt.ylabel("Segment")
plt.tight_layout()
plt.show()
     
```
**Output**
<img width="1454" height="593" alt="AÃânh maÃÄn hiÃÄnh 2026-03-01 luÃÅc 08 43 54" src="https://github.com/user-attachments/assets/36a9a05e-944e-43df-9682-30a462c3d901" />

**Insight** (Customers by Segment):

- The customer base is concentrated in **Champions** (largest segment) and a large inactive pool (**Hibernating customers** and **Lost customers**).
- This suggests Superstore has strong high-value engagement, but also a significant number of customers who have become inactive and may require reactivation strategies.
- For the holiday campaign, broad reach should focus on large segments (Champions / Hibernating / Lost), but incentives should be differentiated to avoid overspending on low-response groups.

**Revenue by segment**

**Cell code**
```python
s = segment_metrics["revenue"].sort_values()
colors = [SEGMENT_COLORS[seg] for seg in s.index]

plt.figure(figsize=(10, 6))
ax = s.plot(kind="barh", color=colors)
ax.grid(axis="x", linestyle="--", alpha=0.3)
ax.spines["top"].set_visible(False)
ax.spines["right"].set_visible(False)
plt.title("Revenue by Segment")
plt.xlabel("Revenue")
plt.ylabel("Segment")
plt.tight_layout()
plt.show()
```
**Output**
<img width="1427" height="594" alt="AÃânh maÃÄn hiÃÄnh 2026-03-01 luÃÅc 08 46 04" src="https://github.com/user-attachments/assets/2fc357d6-8db0-4638-84b7-95c207a890e5" />
**Insight** (Revenue by Segment):

**Champions dominate total revenue**, indicating a small group of highly valuable customers drives a disproportionate share of sales.
**Loyal** and **At Risk** contribute meaningful revenue but are far behind Champions; these are critical ‚Äúsecond-tier‚Äù groups where retention/win-back can protect revenue efficiently.
Marketing should prioritize premium rewards for Champions, while designing targeted win-back offers for At Risk to prevent revenue leakage during the holiday period.

**Median recency by segment**

**Cell code**
```
s = segment_metrics["median_recency"].sort_values()
colors = [SEGMENT_COLORS[seg] for seg in s.index]

plt.figure(figsize=(10, 6))
ax = s.plot(kind="barh", color=colors)
ax.grid(axis="x", linestyle="--", alpha=0.3)
ax.spines["top"].set_visible(False)
ax.spines["right"].set_visible(False)
plt.title("Median Recency by Segment")
plt.xlabel("Median Recency (days)")
plt.ylabel("Segment")
plt.tight_layout()
plt.show()
```
**Output**
<img width="1407" height="612" alt="AÃânh maÃÄn hiÃÄnh 2026-03-01 luÃÅc 08 48 07" src="https://github.com/user-attachments/assets/c658e00c-0a3f-40eb-bfb9-eb26b2ef37c3" />

**Insight** (Median Recency by Segment):

- Recency clearly separates active vs inactive customers: **Champions have the lowest median recency** (most recently active), while **Lost customers** and **Cannot Lose Them** show very high recency (cold customers).
- High recency segments represent churn risk; these customers are less likely to respond without stronger incentives or personalized messaging.
- Recommended focus: keep Champions warm (light rewards + upsell), and run win-back campaigns for At Risk / Cannot Lose Them with personalized offers and reminders to recover high-value customers.

## 7) Insight & Recommendation
